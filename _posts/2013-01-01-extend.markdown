---
layout: chapter
title: Running C in Ruby
---

## Compiling ##

Compiling C code to be loaded as a Ruby extension requires some fancy compiler
options. Luckily, there is an easy way to generate a Makefile containing the
required options using Ruby's `mkmf` stdlib.

### Preparation ###

First create the file `extconf.rb` in the same directory as your C code:

{% highlight ruby linenos %}
{% include ext/extconf.rb %}
{% endhighlight %}

The preparation section should perform actions similar to the standard UNIX
[`configure` script][conf] e.g.

* Check features of the current platform
* Check for existence of required libraries and functions
* Check for programs needed for building

[conf]: http://en.wikipedia.org/wiki/Configure_script

The most common of these actions are provided by `mkmf` (but you have all of
Ruby at your disposal if you need it). For example, an extension which uses SDL2
and needs to know how big `int`s are might call:

{% highlight ruby %}
{% include ext/exex.rb %}
{% endhighlight %}

Calling `create_header` then creates the file `extconf.h` containing
preprocessor definitions based on the results of the prior `mkmf` functions. For
this example, `extconf.h` might contain

{% highlight c %}
{% include ext/exh.h %}
{% endhighlight %}

This header should be included in your C files so that you can adapt your code
to a variety of platforms. Note that you can and should abort the `extconf.rb`
script if a `mkmf` function returns a value that indicates that the build will
fail. For example, if SDL2 is a _requirement_ of your extension you should exit
with some meaningful error message if `have_library('SDL2')` returns `false`.
This is preferred to just generating the Makefile anyway and leaving the user
with an opaque compiler error.

`create_makefile` obviously creates the Makefile, but its argument is especially
important: it defines the entry point of your C code and the name of the
compiled library! Basically, the argument is the name of your extension.

You can modify a few of the generated Makefile variables by modifying the
corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and `$LDFLAGS`[^1]. You can
also use the `$objs` global to define a list of object files for the Makefile if
it's method of automatically generating targets doesn't work for your extension.

All of the `mkmf` functions and their options are well-documented
[online][mkmf]. Note that in addition to the functions for generating
`extconf.h`, there are a variety of functions for handling different source file
layouts, different file dependencies, etc.

[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html

### Execution ###

The rest couldn't be simpler[^2]

    $ ruby extconf.rb
	$ make

But of course that won't do anything without some C code to compile.

## Init ##

Your C code can be structured however you want. The only requirement is that you
must include a function for the Ruby VM to call when your library is `require`d.
The name of the function is determined by the argument you passed to
`create_makefile` in `extconf.rb`. We used "foobar" in our example, so we'll
create `foobar.c` containing

{% highlight c linenos %}
{% include ext/foobar.c %}
{% endhighlight %}

### Filenames ###

Your C file doesn't have to be named after your extension, that's just the idiom
if your extension is simple enough to be contained in a single C file. If your
extension consists of multiple C files, the official documentation recommends
_not_ naming any of them after your extension[^3].

Also avoid naming any files `conftest.c` as this file may be written to by
`mkmf`.

## Success ##

Now make should compile a file like `foobar.so`. Start up `irb` and `require
'./foobar'` to give your extension a try! Now you're ready to learn about the [C
API](../c).

## Footnotes ##

[^1]: I can only find these globals documented in README.EXT.

[^2]: README.EXT [hints](../readme#generate-makefile) that `mkmf` parses certain
	  command line flags e.g.  `--vendor`. But I also can't find this documented
	  anywhere.

[^3]: See [README.EXT](../readme#write-the-c-code). Though I really don't
      understand why it recommends this.
