---
layout: chapter
title: The Ruby C API
---

## Before You Start ##

For the greatest chance of success with this guide, I recommend being fairly
comfortable with C and _very_ comfortable with Ruby.

To be honest, you don't "need" to know any advanced C concepts in order to use
the API; most of the complexity is hidden behind functions and macros. However
the API is **huge** and largely **undocumented**. After you start using it, you
will inevitably find yourself delving through the Ruby source code at some point
to figure out the behavior of some obscure function or macro. The Ruby
source uses some fairly sophisticated C, so you'll need to at least be able to
read it.

In the next section I'll say "everything you can do in Ruby, you can also do
using [the] C API". This is true, but it really should be followed with "...but
it will generally be more unintuitive in C". If you don't have a strong
intuition for the design of Ruby and the best practices in idiomatic Ruby, it
can be extra hard to find the API functions that do what you want.

## The Two Paths ##

The official Ruby interpreter is written in C. That means that everything you
can do in Ruby, you can also do using function calls to Ruby's C API. Why in the
world would you do this? There are two good reasons:

1. You're writing some fancy application in C or C++ and you want some parts of
   your code to leverage the dynamic flexibility of Ruby. You can run the
   Ruby interpreter inside your application and use the API to retrieve the
   results of Ruby code.
2. You're writing some fancy application in Ruby and you want some parts of your
   code to leverage the speed and power of C (or an existing C library). You can
   expose C code to Ruby using the API and compile a special library that Ruby
   can `require`.

You'll need to structure your C code differently depending on your goal. If
you want to embed the Ruby interpreter in C, read [Running Ruby in C](../embed). If
you want to `require` a compiled C library, read [Running C in Ruby](../extend).
After you finish that, come back here to learn about the API.

## Quick 'n' Dirty ##

The simplest way to run some Ruby code from C is to `eval` it

{% highlight c %}
{% include eval.snip %}
{% endhighlight %}

This is a good fallback if you can't find an API function for something that you
want to do. `rb_eval_string_protect()` returns the result of the Ruby code
(all Ruby code returns something) and sets `state` to some nonzero value if any
exception is raised. `VALUE` is the C data type for all Ruby objects, as
explained in the next section.

If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you
should handle the exception. Alternatively, you can use `rb_eval_string()` which
doesn't take a `state` argument and instead raises any exceptions normally. See
[Exceptions](#exceptions) for how to handle both of these cases.

However, like using `eval` in Ruby, using this function is not a good practice.
It's inefficient since it has to invoke the parser and it somewhat defeats the
point of writing in C. Avoid using it whenever possible.

## VALUE ##

Before we go any further, we need to understand `VALUE`s. Due to the danger of
monkeying around inside the VM, the API never lets you directly access Ruby's
objects. Instead, your C code will store and pass around _pointers_ to Ruby
objects (much like variables in Ruby contain pointers to objects). These
pointers can be passed to various API functions and macros that will safely
access and manipulate the Ruby objects. `VALUE` is the API-defined C type for
these pointers.

Probably the most frequent question you'll have is "what is the class of this
`VALUE`?". The easiest way to answer this with the API is to use the `TYPE()`
macro.

{% highlight c %}
{% include type.snip %}
{% endhighlight %}

Given a `VALUE`, `TYPE()` returns one of the [`T_`
constants](../readme#data-types) defined by the API for the core classes.
`TYPE()` works kind of like [`is_a?`][isa]: if you subclass `Array` it will
return `T_ARRAY` for those instances. If none of the other constants make sense
for the `VALUE`, `TYPE()` will return `T_OBJECT` (which makes sense since
everything in Ruby `is_a?  Object`). That's why the `default:` for the above
switch should not normally be reached. Considering raising an
[exception](#exceptions) in that case.

[isa]: http://ruby-doc.org/core-2.1.3/Object.html#method-i-is_a-3F

If you have a specific class in mind, there are faster checks than that big
switch statement:

{% highlight c %}
{% include checktype.snip %}
{% endhighlight %}

And of course you can also call the Ruby method `.class` to get the `VALUE`
pointing to the class object. We'll see how to do that [later](#send).

### Constants ###

Most of the standard Ruby constants have global `VALUE`s defined for them in the
API so you don't need an API call to access them. Modules are prefixed with
`rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` e.g.  `rb_cObject`;
subclasses of `Exception` are prefixed with `rb_e` e.g.  `rb_eRuntimeError`; and
the standard IO streams just have `rb_` e.g.  `rb_stderr`. `nil`, `false`, and
`true` are prefixed with `Q` e.g. `Qnil`. As a convenience, `Qfalse` is also
false in C (`0`).

### Translation ###

A few Ruby classes are analogous to C types. These classes will be your primary
means of transferring data between C and Ruby.

#### Fixnum ####

Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you the
`long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, `FIX2INT()`,
and `FIX2SHORT()`, but these will raise a `RangeError` if the number wouldn't
fit.

In the other direction, `LONG2FIX()` works for `long` **and** every smaller
integer C type[^chr].

#### Bignum ####

Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you need
to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` will get
you `long long` and `unsigned long long` from a `Bignum` (or raise a
`RangeError` if appropriate).

See [Numeric](#numeric) for the reverse direction.

#### Float ####

Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives you the
`double` for a `Float`.

See [Numeric](#numeric) for the reverse direction.

#### Numeric ####

There are a host of "NUM" macros that try to be more duck-typish about things.
These will convert their C types to whatever Ruby `Numeric` subclass seems
appropriate:

* `INT2NUM()` for `int`
* `UINT2NUM()` for `unsigned int`
* `LONG2NUM()` for `long`
* `ULONG2NUM()` for `unsigned long`
* `LL2NUM()` for `long long`
* `ULL2NUM()` for `unsigned long long`
* `DBL2NUM()` for `double`

And then there's the opposite direction, which will try to convert whatever
`Numeric` to the desired C type. All of these should[^range] raise `RangeError`
if there's no reasonable conversion.

* `NUM2CHR()` for `char`
* `NUM2SHORT()` for `short`
* `NUM2USHORT()` for `unsigned short`
* `NUM2INT()` for `int`
* `NUM2UINT()` for `unsigned int`
* `NUM2LONG()` for `long`
* `NUM2ULONG()` for `unsigned long`
* `NUM2LL()` for `long long`
* `NUM2ULL()` for `unsigned long long`
* `NUM2DBL()` for `double`

These macros will generally be a little slower than the ones from the previous
sections as they need to do more checks.

#### String ####

Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is
`StringValueCStr()` which returns a null-terminated `char*` for a `String`. The
problem here is that a Ruby `String` _might contain nulls_ - in which case
`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the
macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly unterminated)
`char*` and the string's length as a `long`[^enc].

Conversely, if you have a null-terminated `char*`, you can use
`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` to
contain nulls, use `rb_str_new()` which takes a `char*` and the string's length
(as a `long`)[^utf].

## Send ##

Now that you can make all of these Ruby objects, you'll probably want to start
sending them methods. The easiest way to do that looks like this:

{% highlight c %}
{% include funcall.snip %}
{% endhighlight %}

This is roughly equivalent to the Ruby code

{% highlight ruby %}
{% include funcall.rb %}
{% endhighlight %}

The first argument is the receiver. The next uses `rb_intern` to return an `ID`
for the method name. `ID` is the C data type corresponding to `Symbol` in Ruby.
The same way that Ruby passes around symbols for method names, the C API passes
around `ID`s. The third argument is the number of method arguments, which is
needed since `rb_funcall` is a varargs function. Then come the actual method
arguments.

Alternatively, you can use `rb_funcallv()` where the fourth argument is a
`VALUE*` pointing to a C array of arguments. This also has the variant
`rb_funcallv_public()` which is like `public_send` in Ruby.

You should prefer this approach should to `rb_eval_string()` and the like
whenever possible. It's faster since it skips the parser and it allows for some
compile-time checking.

## Exceptions ##

If you've been playing around with the API you've almost certainly run into
exceptions by now, so I should probably talk about them.

### Raise ###

To raise an exception, use:

{% highlight c %}
{% include raise.snip %}
{% endhighlight %}

The first and second arguments are the exception class and message &ndash; like
`raise` in Ruby. The big difference is that the message is a format string like
in `printf`[^pi], letting you more easily build a useful message.

### Rescue ###

There are several ways to rescue exceptions using the API. All of them require
the code you're protecting to be in a function that takes and returns a single
`VALUE`.

{% highlight c %}
{% include danger.snip %}
{% endhighlight %}

Unless you wanted to protect a function of exactly this type, you will probably
need to make a wrapper function in this format that makes the desired call. The
way to access a rescued exception is also independent of the way it is rescued:

{% highlight c %}
{% include handle.snip %}
{% endhighlight %}

`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will be
`Qnil` if no exception occurred). Unlike in Ruby, the API does not automatically
clear `$!` after a rescue so you need to clear it manually[^clear]. Otherwise
later API calls might read the old value and think an exception has occurred.

Next we will go over several methods of rescuing; you can use whichever you
like, but I think that generally the right choice is determined by your
[use-case](#the-two-paths) of the API.

#### rb_rescue2 ####

If you're compiling a library to be loaded by Ruby, you have it easy. Any
exceptions raised in the API can be rescued as usual in your Ruby code. If you
want to rescue an exception in the API, you can use `rb_rescue2()` which is
similar to Ruby's `rescue`.

{% highlight c %}
{% include rescue2.snip %}
{% endhighlight %}

The first two arguments are the function to protect and its argument, the next
two are the function to call if an exception is raised and its argument.
`rb_rescue2()` is a varargs function, so after that comes a list of the
exception classes you want to rescue. The last argument should always be `0` to
indicate the end of the class list. Like `rescue` in Ruby, any exceptions not in
this list will not be rescued. If you want to rescue `StandardError` (like a
blank `rescue` in Ruby), you can use `rb_rescue()` which takes just the first
four arguments of `rb_rescue2()`.

The API does not provide an easy way to run different rescue code for different
exception classes as Ruby does. You'll need to rescue all the classes you want
at once and use some kind of switch to handle them separately.

The API also does not directly provide an equivalent to Ruby's `else` i.e. code
to run when _no_ exception was raised. One way to do this is using the return
value of `rb_rescue2()`. If no exception is raised, it returns the return value
of the first (dangerous) function, otherwise the return value of the second
(rescue) function. By having these return, say, `Qtrue` and `Qfalse` you can
detect which case you are in.

#### rb_protect ####

If you're embedding the Ruby interpreter in C, you need to be _extremely
careful_ when calling API functions that could raise exceptions: **an uncaught
exception will segfault the VM and kill your program**. You could call
`rb_rescue2()` with `rb_eException`, but there's another approach for rescuing
all exceptions:

{% highlight c %}
{% include protect.snip %}
{% endhighlight %}

Like `rb_rescue2()`, the first two arguments are for calling the function to
protect. However, like `rb_eval_string_protect()`, if an exception is raised
it returns `Qnil` and sets `state` to some nonzero value. If you want to
re-raise the exception, pass `state` to `rb_jump_tag()` (this works for the
state from `rb_eval_string_protect()` too).

### Ensure ###

`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything
about exceptions and the second function is _always_ called after the first.
That may sound simple enough, but that means if you want the usual `begin;
rescue; ensure; end` structure as in Ruby, you'll need another layer of
wrapping:

{% highlight c %}
{% include ensure.snip %}
{% endhighlight %}

Like `ensure` in Ruby, the return value of `ensure_func()` is never used.  If no
exception occurs, `rb_rescue()` will return the value of `begin_func()` which
returns the value of `dangerous_func()`. If an exception does occur,
`rb_rescue()` returns the value of `rescue_func()`.

## Definitions, Declarations ##

So far we've been creating and modifying objects directly in the VM's memory,
but none of our API calls have had a visible effect _within the Ruby code_. For
example, a `String` made with `rb_str_new_cstr()` is only accessible within the
API &ndash; there's no variable in Ruby for it.

There are a few ways to make things visible to Ruby but they all work the same
general way: by defining some name that Ruby can access e.g. variable name,
method name, etc. A general warning though: unlike Ruby, **the API lets you give
things invalid names**. Ruby will raise a `SyntaxError` or `NameError` if you
try to name a class `foo` (not constant) or an instance variable `bar` (no `@`),
but the API will happily create them.  The API handles this by **not exposing
invalid names to Ruby**. Since that's probably not what you want, double check
the names you choose!

Most of the API functions in this section correspond closely to metaprogramming
methods in Ruby. When you're trying to do something using the API, it can be
helpful to think about how you would do it in Ruby using only metaprogramming
method calls. For example, rather than `class Foo; def bar; end; end`, think `Foo
= Class.new; Foo.define_method(:bar) {}`.

### Global Variables ###

Everyone hates globals, but as always they're the easiest to use.

{% highlight c %}
{% include global.snip %}
{% endhighlight %}

If you're frequently accessing Ruby's globals, you can set up a `VALUE` which
will be automatically synchronized with one.

{% highlight c %}
{% include global2.snip %}
{% endhighlight %}

The `VALUE` should be initialized before you create the global in Ruby and it
should be global in C as well &ndash; you don't want it to go out of scope while
Ruby is using it! For `rb_define_hooked_variable()`, you can pass `0` for the
getter/setter if you want to synchronize normally for that operation. Or you can
throw out `global` entirely with `rb_define_virtual_variable()` though of course
the getter and setter _must_ be defined in that case.

### Instance Variables ###

Getting/setting instance variables is similar to the simple way of accessing
globals, but of course you need an object to get the variable from.

{% highlight c %}
{% include ivar.snip %}
{% endhighlight %}

There isn't an automatic way to synchronize instance variables like you can with
globals.

### Constants ####

You define constants similarly, but you specify the module to define them under:

{% highlight c %}
{% include constant.snip %}
{% endhighlight %}

Getting a constant's `VALUE` is a little nuanced. The API function you call
depends on what you want Ruby to do if the constant is _not_ defined in the
module you specify:

{% highlight c %}
{% include const_get.snip %}
{% endhighlight %}

All of these API calls will get private constants too.

### Modules and Classes ###

Defining modules is super easy.

{% highlight c %}
{% include module.snip %}
{% endhighlight %}

Classes work the same but you need to give them a superclass.

{% highlight c %}
{% include class.snip %}
{% endhighlight %}

Classes are assigned to constants, so you access them the same way as other
constants. I'll also mention briefly that there's `rb_cv_get/set()` for class
variables. They work just like the API functions for instance variables but the
first argument must be a class.

### Methods ###

#### Preparation ####

Here's where it gets interesting again. There are many kinds of API calls for
defining methods, but before you use any of them you'll need a C function which
the method will call. The function must return a `VALUE` and have one `VALUE`
argument for the receiver of the method. There are three ways you can define its
other arguments:

{% highlight c %}
{% include method.snip %}
{% endhighlight %}

So really the API only lets you define two types of methods: ones that take a
fixed number of arguments, and ones that slurp up all their arguments.  What
about all of Ruby's fancy argument features? Where are optional arguments,
keyword arguments, options hashes, blocks, and all the mixtures of those?

Well, if you accept a variable number of arguments you could code all of that
logic yourself in the method, and make it _behave_ like it has a fancier method
definition in Ruby. Thankfully, the API has a shortcut for doing exactly that.
To use it, you should use the C array definition, then you can pass `argc` and
`argv` along to:

{% highlight c %}
{% include scan.h %}
{% endhighlight %}

Here `fmt` is a format string describing how the method arguments would look in
Ruby. The string has at most 6 characters where each character describes a
different section of the arguments. The six sections and their corresponding
characters are (in order):

1. The number of leading mandatory arguments: a digit
2. The number of optional arguments: a digit
3. A splatted argument: `*`
4. The number of trailing mandatory arguments: a digit
5. An options hash: `:`
6. A block argument: `&`

Each section is optional, so you can just leave out the characters for things
you don't need. Be aware that the parsing of the format string is greedy; for
example `1*` describes a method with one mandatory argument and a splat. If you
wanted one _optional_ argument and a splat you would need to specify `01*`.
Following the format string, you must pass a `VALUE*` for each _Ruby_ argument.
The number of pointers passed should equal the "total" of the six sections,
though you can pass `0` for an argument you don't care about. For example
the format string `21*&` should have 5 `VALUE*`s passed.

`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will
raise a fitting exception if the wrong number of arguments were passed.

{% highlight c %}
{% include method2.snip %}
{% endhighlight %}

#### Definition ####

Setting up the C function is the hard part, now it's easy to create the method
in Ruby. Every API call to create a method takes at least the method name
(`char*`), a pointer to your C function, and an `argc` describing its arguments.
`argc` should be:

1. For a fixed number of arguments, the number of arguments (not counting the
   receiver)
2. For a variable number of arguments in a C array, `-1`
3. For a variable number of arguments in a Ruby Array, `-2`

Everything is pretty self-explanatory from there:

{% highlight c %}
{% include method3.snip %}
{% endhighlight %}

There's also a shortcut for defining a method in a module _and_ its
singleton class. This is used a lot in `Math`, for example, letting you `include
Math` to avoid typing `Math.` before every method call.

{% highlight c %}
{% include modulefunc.snip %}
{% endhighlight %}

## Threading ##

## See Also ##

You might be interested in checking out [README.EXT](../readme), which is Ruby's
"official" API documentation. It's included in the Ruby source as a plain text
file, but I've HTML-ified it for nicer online reading. It has a bit more
information than this guide, but in most cases that's because I intentionally
omitted something that I either found not useful or better documented elsewhere.

I think one of the handiest resources is the `ruby.h` header itself. The "full
API" (i.e. everything you get by including `ruby.h`) easily consists of a
thousand functions, macros, constants, and globals &ndash; most of which have
never been documented. However _most_ things are reasonably named and you should
be able to figure out what they do from the header. You should be able to use
your compiler to "expand" `ruby.h` to show everything that it pulls in. For gcc,
I use

    $ echo '#include <ruby.h>' | gcc -E -P -dD `pkg-config --cflags ruby-2.1` -xc -o ruby.h -

If you find some function in the header that isn't documented anywhere, your
next stop should be the Ruby source code.

    $ git clone https://github.com/ruby/ruby.git

When reading through the source code, always keep the header at hand: there are
lots of really useful functions in there that _look_ like they should be in the
API, but actually aren't. Though in most cases there should be an API function
elsewhere that wraps the call to the useful function.

## Footnotes ##

[^chr]: There is `CHR2FIX()`. But that just does some seemingly pointless
        binary math before using `LONG2FIX()`.

[^range]: I haven't checked.

[^enc]: I'm not sure how to deal with different encodings (especially wide ones).

[^utf]: Again, the documentation [mentions](../readme#string-functions) that
        there are ways to create UTF-8 strings (`rb_utf8_str_new`), but I
        couldn't get them to work.

[^pi]: The documentation [claims](../readme#exceptions-and-errors) to support the
       additional format directives `%i` and `%+i` for `to_s` and `inspect` (both
       take a `VALUE`) but these printed garbage in my tests.

[^clear]: The documentation [states](../readme#control-structure) that "You have to
          clear the error info [when] ignoring the caught exception". But I can't
          find any documentation of when it would be cleared for you &ndash; it seems
          like you _always_ have to clear it.
