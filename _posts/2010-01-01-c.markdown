---
layout: chapter
title: The Ruby C API
---

## Before You Start ##

For the greatest chance of success with this guide, I recommend being fairly
comfortable with C and _very_ comfortable with Ruby.

To be honest, you don't "need" to know any advanced C concepts in order to use
the API; most of the complexity is hidden behind functions and macros. However
the API is **huge** and largely **undocumented**. After you start using it, you
will inevitably find yourself delving through the Ruby source code at some point
to figure out the behavior of some obscure function or macro. The Ruby
source uses some fairly sophisticated C, so you'll need to at least be able to
read it.

In the next section I'll say "everything you can do in Ruby, you can also do
using [the] C API". This is true, but it really should be followed with "...but
it will generally be more unintuitive in C". If you don't have a strong
intuition for the design of the language and the best practices in idiomatic
Ruby, it can be extra hard to find the API functions that do what you want.

## The Two Paths ##

The official Ruby interpreter is written in C. That means that everything you
can do in Ruby, you can also do using function calls to Ruby's C API. Why in the
world would you do this? There are two good reasons:

1. You're writing some fancy application in C or C++ and you want some parts of
   your code to leverage the dynamic flexibility of Ruby. You can run the
   Ruby interpreter inside your application and use the API to retrieve the
   results of Ruby code.
2. You're writing some fancy application in Ruby and you want some parts of your
   code to leverage the speed and power of C (or an existing C library). You can
   expose C code to Ruby using the API and compile a special library that Ruby
   can `require`.

You'll need to structure your C code differently depending on your goal. If
you want to embed the Ruby interpreter in C, read [Running Ruby in C](../embed). If
you want to `require` a compiled C library, read [Running C in Ruby](../extend).
After you finish that, come back here to learn about the API.

## Quick 'n' Dirty ##

The simplest way to run some Ruby code from C is to `eval` it

{% highlight c %}
{% include eval.snip %}
{% endhighlight %}

This is a good fallback if you can't find an API function for something that you
want to do. `rb_eval_string_protect()` returns the result of the Ruby code
(remember that all Ruby code returns something) and sets `state` to some nonzero
value if any exception is raised. `VALUE` is the C data type for all Ruby
objects, as explained in the next section.

If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you
should handle the exception. Alternatively, you can use `rb_eval_string()` which
doesn't take a `state` argument and instead raises any exceptions normally. See
[Exceptions](#exceptions) for how to handle both of these cases.

However, just like `eval` in Ruby, use of this function is not good practice.
It's inefficient since it has to invoke the parser and it somewhat defeats the
point of writing in C. Avoid using it whenever possible.

## VALUE ##

Before we go any further, we need to understand `VALUE`s. Due to the danger of
monkeying around inside the VM, the API never lets you directly access Ruby's
objects. Instead, your C code will store and pass around _pointers_ to Ruby
objects (much like variables in Ruby contain pointers to objects). These
pointers can be passed to various API functions and macros that will safely
access and manipulate the Ruby objects. `VALUE` is the API-defined C type for
these pointers.

Probably the most frequent question you'll have is "what is the class of this
`VALUE`?". The easiest way to answer this with the API is to use the `TYPE()`
macro.

{% highlight c %}
{% include type.snip %}
{% endhighlight %}

Given a `VALUE`, `TYPE()` returns one of the [`T_`
constants](../readme#data-types) defined by the API for the core classes. Note
that `TYPE()` works kind of like [`is_a?`][isa]: if you subclass `Array` it will
return `T_ARRAY` for those instances. If none of the other constants make sense
for the `VALUE`, `TYPE()` will return `T_OBJECT` (which makes sense since
everything in Ruby `is_a?  Object`). That's why the `default:` for the above
switch should not normally be reached. Considering raising an
[exception](#exceptions) in that case.

[isa]: http://ruby-doc.org/core-2.1.3/Object.html#method-i-is_a-3F

If you have a specific class in mind, there are faster checks than that big
switch statement:

{% highlight c %}
{% include checktype.snip %}
{% endhighlight %}

And of course you can also call the Ruby method `.class` to get the `VALUE`
pointing to the class object. We'll see how to do that [later](#methods).

## Translation ##

A few Ruby classes are analogous to C types. These classes will be your primary
means of transferring data between C and Ruby.

### Constants ###

Ruby's constants each get a corresponding constant `VALUE` in the API: `Qnil`
for `nil`, `Qfalse` for `false`, and `Qtrue` for `true`. As a convenience,
`Qfalse` is also false in C (i.e. `0`).

### Fixnum ###

Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you the
`long` for a `Fixnum`. `FIX2INT()` will give you an `int` instead, but will
raise a `RangeError` if the result wouldn't fit (there's also `FIX2UINT()` if
that one bit makes all the difference).

As you might expect, `LONG2FIX()` and `INT2FIX()` are for translating in the
other direction. There's also `CHR2FIX()` for `char` (though `FIX2CHR()` is
missing for some reason).

### Bignum ###

Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you need
to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` will get
you `long long` and `unsigned long long` from a `Bignum` (or raise a
`RangeError` if appropriate).

See [Numeric](#numeric) for the reverse direction.

### Float ###

Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives you the
`double` for a `Float`.

See [Numeric](#numeric) for the reverse direction.

### Numeric ###

There are a host of "NUM" macros that try to be more duck-typish about things.
These will convert their C types to whatever Ruby `Numeric` subclass seems
appropriate:

* `INT2NUM()` for `int`
* `UINT2NUM()` for `unsigned int`
* `LONG2NUM()` for `long`
* `ULONG2NUM()` for `unsigned long`
* `LL2NUM()` for `long long`
* `ULL2NUM()` for `unsigned long long`
* `DBL2NUM()` for `double`

And then there's the opposite direction, which will try to convert whatever
`Numeric` to the desired C type. All of these should[^range] raise `RangeError`
if there's no reasonable conversion.

* `NUM2CHR()` for `char`
* `NUM2SHORT()` for `short`
* `NUM2USHORT()` for `unsigned short`
* `NUM2INT()` for `int`
* `NUM2UINT()` for `unsigned int`
* `NUM2LONG()` for `long`
* `NUM2ULONG()` for `unsigned long`
* `NUM2LL()` for `long long`
* `NUM2ULL()` for `unsigned long long`
* `NUM2DBL()` for `double`

Note that these macros will generally be a little slower than the ones from the
previous sections as they need to do more checks.

### String ###

Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is
`StringValueCStr()` which returns a null-terminated `char*` for a `String`. The
problem here is that a Ruby `String` _might contain nulls_ - in which case
`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the
macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly unterminated)
`char*` and the string's length as a `long`[^enc].

Conversely, if you have a null-terminated `char*`, you can use
`rb_str_new_cstr()` to create a Ruby `String`. `rb_str_new()` constructs a
`String` from a `char*` and the string's length (as a `long`)[^utf].

## Methods ##

Now that you can make all of these Ruby objects, you'll probably want to start
sending them methods. The easiest way to do this looks like this:

{% highlight c %}
{% include funcall.snip %}
{% endhighlight %}

This is roughly equivalent to the Ruby code

{% highlight ruby %}
{% include funcall.rb %}
{% endhighlight %}

The first argument is the receiver. The next uses `rb_intern` to return an `ID`
for the method name. `ID` is the C data type corresponding to `Symbol` in Ruby.
The same way that Ruby passes around symbols for method names, the C API passes
around `ID`s. The third argument is the number of method arguments, which is
needed since `rb_funcall` is a varargs function. Then come the actual method
arguments.

Alternatively, you can use `rb_funcallv()` where the fourth argument is a
`VALUE*` pointing to a C array of arguments. This also has the variant
`rb_funcallv_public()` which is like `public_send` in Ruby.

Whenever possible, this approach should be used instead of the
[quick'n'dirty](#quick-n-dirty) `rb_eval_string()`. It's faster
since it skips the parser and it allows for some compile-time checking.

## Exceptions ##

If you've been playing around with the API you've almost certainly run into
exceptions by now, so I should probably talk about them.

### Raise ###

To raise an exception, use:

{% highlight c %}
{% include raise.snip %}
{% endhighlight %}

The first and second arguments are the exception class and message, just like
`raise` in Ruby (all exception classes in the API start with `rb_e`). The big
difference is that the message is a format string just like in `printf`[^pi],
letting you more easily build a useful message.

There is no shortcut for re-raising the last exception. Just call
`Kernel.raise`.

### Rescue ###

There are several ways to rescue exceptions using the API. All of them require
the code you're protecting to be in a function that takes and returns a single
`VALUE`.

{% highlight c %}
{% include danger.snip %}
{% endhighlight %}

Unless you wanted to protect a function of exactly this type, you will probably
need to make a wrapper function in this format that makes the desired call. You
will always read the rescued exception object the same way:

{% highlight c %}
{% include handle.snip %}
{% endhighlight %}

`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will be
`Qnil` if no exception occured). Unlike in Ruby, the API does not automatically
clear `$!` after a rescue so you need to clear it manually[^clear]. Otherwise
later API calls might read the old value and think an exception has occurred.

Next we will go over several methods of rescuing; you can use whichever you
like, but I think that generally the right choice is determined by your
[use-case](#the-two-paths) of the API.

#### rb_rescue2 ####

If you're compiling a library to be loaded by Ruby, you have it easy. Any
exceptions raised in the API can be rescued as usual in your Ruby code. If you
want to rescue an exception in the API, you can use `rb_rescue2()` which works
very similar to Ruby's `rescue`.

{% highlight c %}
{% include rescue2.snip %}
{% endhighlight %}

The first two arguments are the function to protect and its argument, the next
two are the function to call if an exception is raised and its argument.
`rb_rescue2()` is a varargs function, so after that comes a list of the
exception classes you want to rescue. The last argument should always be `0` as
this indicates the end of the class list. Just like in Ruby, any exceptions not
in this list will not be rescued. If you just want to rescue `StandardError`
(like a blank `rescue` in Ruby), you can use `rb_rescue()` which uses just the
first four arguments of `rb_rescue2()`.

The API does not provide an easy way to run different rescue code for different
exception classes as Ruby does. You'll need to rescue all the classes you want
at once and use some kind of switch to handle them separately.

The API also does not directly provide an equivalent to Ruby's `else` i.e. code
to run when _no_ exception was raised. One way to do this is using the return
value of `rb_rescue2()`. If no exception is raised, it returns the return value
of the first (dangerous) function, otherwise the return value of the second
(rescue) function. By having these return, say, `Qtrue` and `Qfalse` you can
detect which case you are in.

#### rb_protect ####

If you're embedding the Ruby interpreter in C, you need to be _extremely
careful_ when calling API functions that could raise exceptions: **an uncaught
exception will segfault the VM and kill your program**. You could call
`rb_rescue2()` with `rb_eException`, but there's another approach for rescuing
all exceptions:

{% highlight c %}
{% include protect.snip %}
{% endhighlight %}

Like `rb_rescue2()`, the first two arguments are for calling the function to
protect. However, like `rb_eval_string_protect()`, if an exception is raised
it returns `Qnil` and sets `status` to some nonzero value.

### Ensure ###

`rb_ensure()` works similarly to `rb_rescue()` except that it doesn't do
anything about exceptions and the second function is _always_ called after the
first. That may sound simple enough, but that means if you want the usual
`begin; rescue; ensure; end` structure as in Ruby, you'll need another layer of
wrapping:

{% highlight c %}
{% include ensure.snip %}
{% endhighlight %}

Note that the return value of `ensure_func()` is actually never used. If no
exception occurs, `rb_rescue()` will return the value of `begin_func()` which
returns the value of `dangerous_func()`. If an exception does occur,
`rb_rescue()` returns the value of `rescue_func()`.

## Footnotes ##

[^range]: I haven't checked.

[^enc]: I'm not sure how to deal with different encodings (especially wide ones).

[^utf]: Again, the documention [mentions](../readme#string-functions) that there
	  are ways to create UTF-8 strings (`rb_utf8_str_new`), but I couldn't get
	  them to work.

[^pi]: The documentation [claims](../readme#exceptions-and-errors) to support the
	  additional format directives `%i` and `%+i` for `to_s` and `inspect` (both
	  take a `VALUE`) but these printed garbage in my tests.

[^clear]: The documentation [states](../reamde#control-structure) that "You have to
	 clear the error info [when] ignoring the caught exception". But I can't
	 find any documentation of when it would be cleared for you &ndash; it seems
	 like you _always_ have to clear it.

