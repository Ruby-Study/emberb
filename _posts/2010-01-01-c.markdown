---
layout: chapter
title: The Ruby C API
---

## Before You Start ##

For the greatest chance of success with this guide, I recommend being fairly
comfortable with C and _very_ comfortable with Ruby.

To be honest, you don't "need" to know any advanced C concepts in order to use
the API; most of the complexity is hidden behind functions and macros. However
the API is **huge** and largely **undocumented**. After you start using it, you
will inevitably find yourself delving through the Ruby source code at some point
to figure out the behavior of some obscure function or macro. The Ruby
source uses some fairly sophisticated C, so you'll need to at least be able to
read it.

In the next section I'll say "everything you can do in Ruby, you can also do
using [the] C API". This is true, but it really should be followed with "...but
it will generally be more unintuitive in C". If you don't have a strong
intuition for the design of the language and the best practices in idiomatic
Ruby, it can be extra hard to find the API functions that do what you want.

## The Two Paths ##

The official Ruby interpreter is written in C. That means that everything you
can do in Ruby, you can also do using function calls to Ruby's C API. Why in the
world would you do this? There are two good reasons:

1. You're writing some fancy application in C or C++ and you want some parts of
   your code to leverage the dynamic flexibility of Ruby. You can run the
   Ruby interpreter inside your application and use the API to retrieve the
   results of Ruby code.
2. You're writing some fancy application in Ruby and you want some parts of your
   code to leverage the speed and power of C (or an existing C library). You can
   expose C code to Ruby using the API and compile a special library that Ruby
   can `require`.

You'll need to structure your C code differently depending on your goal. If
you want to embed the Ruby interpreter in C, read [Running Ruby in C](../embed). If
you want to `require` a compiled C library, read [Running C in Ruby](../extend).
After you finish that, come back here to learn about the API.

## Quick 'n' Dirty ##

The simplest way to run some Ruby code from C is to `eval` it

{% highlight c %}
{% include eval.snip %}
{% endhighlight %}

This is a good fallback if you can't find an API function for something that you
want to do. `rb_eval_string_protect` returns the result of the Ruby code
(remember that all Ruby code returns something) and sets `state` to some nonzero
value if any exception is raised. `VALUE` is the C data type for all Ruby
objects, as explained in the next section.

If `state` is nonzero, you should be able to get information about the error by
accessing the variable `$!` (as you would in Ruby). If you are embedding
the Ruby VM, `state` can be passed to `ruby_cleanup` for automatic error message
output.  Alternatively, you can use `rb_eval_string()` which raises any
exceptions normally (see [Exceptions][exc]).

However, just like `eval` in Ruby, this approach is inefficient and somewhat
defeats the point of writing in C. Avoid using it whenever possible. Using the
API, it is possible to directly manipulate Ruby's data structures, which is much
more efficient than passing strings to the interpreter.

## VALUE ##

Before we go any further, we need to understand `VALUE`s. Due to the danger of
monkeying around inside the VM, the API never lets you directly access Ruby's
objects. Instead, your C code will store and pass around _pointers_ to Ruby
objects (much like variables in Ruby contain pointers to objects). These
pointers can be passed to various API functions and macros that will safely
access and manipulate the Ruby objects. `VALUE` is the API-defined C type for
these pointers.

Probably the most frequent question you'll have is "what is the class of this
`VALUE`?". The easiest way to answer this with the API is to use the `TYPE()`
macro.

{% highlight c %}
{% include type.snip %}
{% endhighlight %}

The various [`T_` constants](../readme#data-types) are defined by the API for all of
Ruby's core classes and `TYPE()` simply returns the appropriate constant for
the `VALUE`. Note that `TYPE()` works kind of like [`is_a?`][isa]: if you
subclass `Array` it will return `T_ARRAY` for those instances. If none of the
other constants make sense for the `VALUE`, `TYPE()` will return `T_OBJECT`
(which makes sense since everything in Ruby `is_a? Object`). That's why the
`default:` for the above switch should not normally be reached. Considering
raising an [exception][exc] in that case.

[exc]: #TODO
[isa]: http://ruby-doc.org/core-2.1.3/Object.html#method-i-is_a-3F

If you have a specific class in mind, there are faster checks than that big
switch statement:

{% highlight c %}
{% include checktype.snip %}
{% endhighlight %}

And of course you can also [call][meth] the Ruby method `.class` to get the `VALUE` pointing
to the class object. We'll see how to do that later.

[meth]: #TODO

## Translation ##

A few Ruby classes are analogous to C types. These classes will be your primary
means of transferring data between C and Ruby.

### Fixnum ###

Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you the
`long` for a `Fixnum`. `FIX2INT()` will give you an `int` instead, but will
raise a `RangeError` if the result wouldn't fit (there's also `FIX2UINT()` if
that one bit makes all the difference).

As you might expect, `LONG2FIX()` and `INT2FIX()` are for translating in the
other direction. There's also `CHR2FIX()` for `char` (though `FIX2CHR()` is
missing for some reason).

### Bignum ###

Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you need
to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` will get
you `long long` and `unsigned long long` from a `Bignum` (or raise a
`RangeError` if appropriate).

See [Numeric](#numeric) for the reverse direction.

### Float ###

Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives you the
`double` for a `Float`.

See [Numeric](#numeric) for the reverse direction.

### Numeric ###

There are a host of "NUM" macros that try to be more duck-typish about things.
These will convert their C types to whatever Ruby `Numeric` subclass seems
appropriate:

* `INT2NUM()` for `int`
* `UINT2NUM()` for `unsigned int`
* `LONG2NUM()` for `long`
* `ULONG2NUM()` for `unsigned long`
* `LL2NUM()` for `long long`
* `ULL2NUM()` for `unsigned long long`
* `DBL2NUM()` for `double`

And then there's the opposite direction, which will try to convert whatever
`Numeric` to the desired C type. All of these should[^1] raise `RangeError` if
there's no reasonable conversion.

* `NUM2CHR()` for `char`
* `NUM2SHORT()` for `short`
* `NUM2USHORT()` for `unsigned short`
* `NUM2INT()` for `int`
* `NUM2UINT()` for `unsigned int`
* `NUM2LONG()` for `long`
* `NUM2ULONG()` for `unsigned long`
* `NUM2LL()` for `long long`
* `NUM2ULL()` for `unsigned long long`
* `NUM2DBL()` for `double`

Note that these macros will generally be a little slower than the ones from the
previous sections as they need to do more checks.

### String ###

Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is
`StringValueCStr()` which returns a null-terminated `char*` for a `String`. The
problem here is that a Ruby `String` _might contain nulls_ - in which case
`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the
macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly unterminated)
`char*` and the string's length as a `long`[^2].

Conversely, if you have a null-terminated `char*`, you can use
`rb_str_new_cstr()` to create a Ruby `String`. `rb_str_new()` constructs a
`String` from a `char*` and the string's length (as a `long`)[^3].

## Methods ##

Now that you can make all of these Ruby objects, you'll probably want to start
sending them methods. The easiest way to do this looks like this:

{% highlight c %}
{% include funcall.snip %}
{% endhighlight %}

This is roughly equivalent to the Ruby code

{% highlight ruby %}
{% include funcall.rb %}
{% endhighlight %}

The first argument is the receiver. The next uses `rb_intern` to return an `ID`
for the method name. `ID` is the C data type corresponding to `Symbol` in Ruby.
The same way that Ruby passes around symbols for method names, the C API passes
around `ID`s. The third argument is the number of method arguments, which is
needed since `rb_funcall` is a varargs function. Then come the actual method
arguments.

Alternatively, you can use `rb_funcallv()` where the fourth argument is a
`VALUE*` pointing to a C array of arguments. This also has the variant
`rb_funcallv_public()` which is like `public_send` in Ruby.

Whenever possible, this approach should be used instead of the
[quick'n'dirty](#quick-n-dirty) `rb_eval_string()`. It's faster
since it skips the parser and it allows for some compile-time checking.

## Exceptions ##

If you've been playing around with the API, you've almost certainly run
into exceptions by now, so I should probably talk about them. First to raise an
exception, use:

{% highlight c %}
{% include raise.snip %}
{% endhighlight %}

The first and second arguments are the exception class and message, just like
`raise` in Ruby (all exception classes start with `rb_e`). The big difference is
that the message is a format string just like in `printf`[^4], letting you more
easily include relevant information.

## Footnotes ##

[^1]: I haven't checked.

[^2]: I'm not sure how to deal with different encodings (especially wide ones).

[^3]: Again, the documention mentions that there are ways to create UTF-8
      strings (`rb_utf8_str_new`), but I couldn't get them to work.

[^4]: The documentation [claims](../readme#exceptions-and-errors) to support the
	  additional format directives `%i` and `%+i` for `to_s` and `inspect` (both
	  take a `VALUE`) but these printed garbage in my tests.
