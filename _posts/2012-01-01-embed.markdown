---
layout: chapter
title: Running Ruby in C
---

## Compiling ##

Embedding Ruby requires one header `ruby.h`, which includes a platform-specific
header `ruby/config.h`. You will probably need to tell your compiler about the
include paths for these headers. You will also need to link with the Ruby lib.
On my machine, my minimal compiler options are

    -I/usr/include/ruby-2.1.0 -I/usr/include/ruby-2.1.0/x86_64-linux -lruby

Though, if available, you should really use `pkg-config` to get the appropriate
options for your distribution:

    $ pkg-config --cflags --libs ruby-2.1

## Startup, Teardown ##

Including the Ruby interpreter in your C/C++ program is pretty simple. Just
include the header and bookend your API calls with some function calls.

{% highlight c linenos %}
{% include simple.c %}
{% endhighlight %}

`ruby_init()` constructs the VM. However, if the VM fails to start it will
print an error and exit your program! If you would rather have a softer error,
you can instead call `ruby_setup()` which returns a nonzero value if a failure
occurred (unfortunately there is no way to get a message for the error[^err]).

`ruby_cleanup(0)` destructs the VM. If an error occurs during cleanup it returns
a nonzero value &ndash; otherwise it returns the argument you passed it. This
allows a little shortcut for returning an error status if the cleanup fails (as
demonstrated in the previous example).

During cleanup, the VM might evaluate more Ruby code (if you passed a block to
`at_exit`, for example) which could raise an exception. `ruby_cleanup`
suppresses such exceptions, but if you instead call `ruby_finalize()` they will
be raised normally (see the section on [Exceptions][exc] for how to handle
them).

[exc]: TODO

Here's an alternative example:

{% highlight c linenos %}
{% include advanced.c %}
{% endhighlight %}

## Tweaking the VM ##

You now have a bare-bones Ruby VM running, but you may want to set up a little
more stuff before you start running Ruby code. To set the name of the Ruby
script (e.g. `$0`) for error messages and such, use

{% highlight c %}
void ruby_script(const char *name);
{% endhighlight %}

To set up the load path so that gems can be loaded with `require`, use

{% highlight c %}
void ruby_init_loadpath(void);
{% endhighlight %}

You can also pass options to the VM just like you would to `ruby` on the command
line. This is handy for stuff like setting the warning level or verbose
mode[^opt].

{% highlight c linenos %}
{% include options.c %}
{% endhighlight %}

The arguments to `ruby_options` are `argc` and `argv` just like a main function.
And just like the main of the `ruby` program, the VM expects to get some Ruby
code when you call it. If you don't give it the filename of a script to load or
code to run with `-e`, it will try to read from `stdin`. If you want to set
options but _not_ run any Ruby code, you can pass it an empty line: `"-e "`.

`ruby_options` returns a "node" that represents the compiled Ruby code. In some
cases (such as a syntax error) the node will be invalid and you shouldn't run
it. `ruby_executable_node` checks for this. If the node is valid, you can run it
with `ruby_exec_node`. The status returned by `ruby_executable_node` (through
the pointer) and by `ruby_exec_node` can be passed to `ruby_cleanup` to print an
appropriate error message[^hand].

## Footnotes ##

[^err]: `ruby_init` uses `error_print()` to get an error message, but this
        function isn't exposed to the API.

[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do anything. This
        could be related to `ruby_prog_init()`.

[^hand]: `ruby_cleanup` does this by calling `error_handle(status)`, but again
         this is not exposed to the API. It is not clear if this is possible to
		 do without cleaning up the VM.
